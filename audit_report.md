# Отчет по аудиту кода проекта MashaGPT

## 1. Общий вердикт

**Требует значительных доработок.**

Проект имеет прочную архитектурную основу, использует современный асинхронный стек и следует ряду хороших практик (управление конфигурацией через `.env`, многоэтапная сборка Docker, использование Alembic). Однако для безопасного и надежного запуска в production необходимо устранить несколько критических и важных проблем в области безопасности, надежности, производительности и наблюдаемости.

---

## 2. Приоритетный список проблем

### Критические проблемы

1.  **Некорректная работа Rate Limiter'а:** Ограничение по IP вместо ID пользователя создает риск DoS и позволяет обходить лимиты.
2.  **Отсутствие механизма Retry для внешних вызовов:** Кратковременные сбои сети или API приведут к немедленным ошибкам.
3.  **Полное отсутствие метрик и трассировки:** Невозможно отслеживать состояние и производительность приложения в реальном времени.
4.  **Запуск от имени `root` в контейнере:** Создает серьезную уязвимость в случае эксплуатации ошибки в приложении.

### Важные проблемы

1.  **Хранение FSM-состояний в памяти:** Приводит к потере данных при перезапуске и не работает при масштабировании.
2.  **Небезопасная работа с временными файлами:** Создает риск состояния гонки и лишнюю нагрузку на диск.
3.  **Неструктурированное и неконсистентное логирование:** Затрудняет отладку и мониторинг в production.
4.  **Неэффективное обновление профиля в БД:** Выполняет два запроса вместо одного (UPSERT).
5.  **Использование неточных тегов для Docker-образов:** Приводит к недетерминированным сборкам.
6.  **Смешение ответственности в `bot/handlers.py`:** Файл слишком большой и сложный для поддержки.
7.  **Неполная обработка всех видов ошибок от Gemini API:** Приложение не всегда корректно реагирует на разные причины завершения генерации.

### Рекомендации

1.  **Защита от Prompt Injection:** Пользовательский ввод напрямую попадает в системный промпт.
2.  **Использование Enum вместо "магических строк"**: Улучшит читаемость и надежность кода.
3.  **Оптимизация создания API-клиентов:** Клиенты должны создаваться один раз за жизненный цикл приложения.
4.  **Отсутствие `healthcheck` для PostgreSQL:** Может приводить к ошибкам при старте всего стека.
5.  **Улучшение валидации данных:** Использовать `.get()` для безопасного доступа к данным из словаря.

---

## 3. Детальный разбор проблем

### 3.1. Безопасность

#### 1. Некорректная работа Rate Limiter'а (Критическая)
*   **Описание:** Ограничитель запросов в `main.py` настроен на использование IP-адреса клиента (`get_remote_address`) вместо `user_id`.
*   **Расположение:** [`main.py:19-23`](main.py:19:23)
*   **Риски:** Один злоумышленник с нескольких IP может создать большую нагрузку. Несколько легитимных пользователей с одного IP могут заблокировать друг друга.
*   **Рекомендация:** Изменить ключевую функцию лимитера для извлечения `user_id` из тела запроса.

#### 2. Запуск от имени `root` в контейнере (Важная)
*   **Описание:** В `Dockerfile` не создается непривилегированный пользователь для запуска приложения.
*   **Расположение:** [`Dockerfile`](Dockerfile)
*   **Риски:** В случае успешной атаки на приложение злоумышленник получит права `root` внутри контейнера, что упрощает дальнейшее развитие атаки.
*   **Рекомендация:** В `Dockerfile` создать пользователя `app`, сменить владельца файлов на него (`chown -R app:app /app`) и переключиться на него с помощью инструкции `USER app` перед `CMD`.

#### 3. Небезопасная работа с временными файлами (Важная)
*   **Описание:** Голосовые сообщения создаются как файлы на диске с предсказуемыми именами.
*   **Расположение:** [`main.py:66-75`](main.py:66:75)
*   **Риски:** Состояние гонки при одновременных запросах от одного пользователя; лишняя нагрузка на файловую систему.
*   **Рекомендация:** Генерировать файл в памяти, используя `io.BytesIO`, и передавать байты напрямую, не сохраняя их на диск.

#### 4. Защита от Prompt Injection (Рекомендация)
*   **Описание:** Данные из профиля пользователя без санации вставляются в системный промпт.
*   **Расположение:** [`server/ai.py:97-98`](server/ai.py:97:98)
*   **Риски:** Пользователь может внедрить в свой профиль инструкции, которые изменят поведение LLM.
*   **Рекомендация:** Добавить в системный промпт явное указание игнорировать попытки пользователя изменить инструкции. Проводить базовую санацию пользовательского ввода.

### 3.2. Производительность и масштабируемость

#### 1. Неэффективное обновление профиля в БД (Важная)
*   **Описание:** Функция `create_or_update_profile` делает `SELECT`, а затем `INSERT` или `UPDATE`.
*   **Расположение:** [`server/database.py:22-37`](server/database.py:22:37)
*   **Риски:** Два обращения к БД вместо одного, что увеличивает задержку и нагрузку.
*   **Рекомендация:** Использовать атомарную операцию `UPSERT`. Для PostgreSQL это `insert().on_conflict_do_update()`.

#### 2. Хранение FSM-состояний в памяти (Важная)
*   **Описание:** Состояния конечного автомата для анкеты хранятся в глобальном словаре `fsm_storage`.
*   **Расположение:** [`main.py:116`](main.py:116)
*   **Риски:** Потеря данных при перезапуске; неработоспособность при горизонтальном масштабировании (несколько воркеров).
*   **Рекомендация:** Использовать внешнее персистентное хранилище для состояний, например, Redis.

### 3.3. Надежность и обработка ошибок

#### 1. Отсутствие механизма Retry (Критическая)
*   **Описание:** Вызовы к внешним API (Gemini, Geopy, собственный API) не имеют логики повторных попыток.
*   **Расположение:** `bot/handlers.py`, `server/ai.py`, `server/tts.py`.
*   **Риски:** Кратковременные сетевые сбои или недоступность API приведут к немедленной ошибке и плохому пользовательскому опыту.
*   **Рекомендация:** Использовать библиотеку `tenacity` (уже в зависимостях) для оборачивания всех внешних вызовов в декоратор `@retry` с настроенными интервалами и количеством попыток.

#### 2. Неполная обработка ошибок от Gemini API (Важная)
*   **Описание:** В `server/ai.py` не обрабатываются все возможные причины завершения генерации (`finish_reason`), такие как `MAX_TOKENS`.
*   **Расположение:** [`server/ai.py:182`](server/ai.py:182)
*   **Риски:** Пользователь получит общий и непонятный ответ об ошибке, что затруднит и использование, и отладку.
*   **Рекомендация:** Анализировать `candidate.finish_reason` и давать пользователю более осмысленные ответы для каждого случая.

### 3.4. Наблюдаемость (Observability)

#### 1. Полное отсутствие метрик и трассировки (Критическая)
*   **Описание:** В приложении нет сбора метрик (Prometheus) и трассировки (OpenTelemetry).
*   **Риски:** "Слепая" эксплуатация. Невозможно отслеживать производительность, находить узкие места и проактивно реагировать на проблемы.
*   **Рекомендация:** Интегрировать `starlette-prometheus` для сбора метрик FastAPI и `OpenTelemetry` для сквозной трассировки запросов.

#### 2. Неструктурированное логирование (Важная)
*   **Описание:** Используются простые строковые логи и `print()`, отсутствует контекст (`user_id`, `trace_id`).
*   **Расположение:** По всему проекту.
*   **Риски:** Крайне затрудняет отладку и автоматизированный анализ логов в production.
*   **Рекомендация:** Использовать `structlog` для вывода логов в JSON. Централизовать конфигурацию логгера. Добавлять `user_id` в контекст логов.

### 3.5. Качество кода и конфигурация

#### 1. Смешение ответственности (Важная)
*   **Описание:** Файл `bot/handlers.py` содержит логику FSM, UI, работы с геолокацией и обработки команд.
*   **Расположение:** [`bot/handlers.py`](bot/handlers.py)
*   **Риски:** Файл сложно читать, поддерживать и тестировать.
*   **Рекомендация:** Разделить логику на несколько файлов по принципу единственной ответственности (`handlers/start.py`, `handlers/onboarding.py` и т.д.).

#### 2. Использование неточных тегов Docker-образов (Важная)
*   **Описание:** Используются теги `python:3.10-slim` и `postgres:15`.
*   **Расположение:** [`Dockerfile`](Dockerfile), [`docker-compose.yml`](docker-compose.yml)
*   **Риски:** Сборки не являются детерминированными. Обновление минорной версии базового образа может привести к неожиданным ошибкам.
*   **Рекомендация:** Указывать максимально конкретные теги, например, `python:3.10.12-slim-bullseye` и `postgres:15.4-alpine`.

#### 3. Отсутствие `healthcheck` для PostgreSQL (Рекомендация)
*   **Описание:** В `docker-compose.yml` используется `depends_on` без `healthcheck`.
*   **Расположение:** [`docker-compose.yml`](docker-compose.yml)
*   **Риски:** Приложение может попытаться подключиться к БД до того, как она будет готова, что вызовет ошибки при старте.
*   **Рекомендация:** Добавить секцию `healthcheck` для сервиса `db` и использовать `condition: service_healthy` в `depends_on`.